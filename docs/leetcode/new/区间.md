# 区间

区间问题通常需要考虑排序, 按左还是右排序很关键  
考虑 2 个区间的场景:

-   相交
-   包含
-   不相交

## 合并区间

### 56. 合并区间 mid

以数组 intervals 表示若干个区间的集合, 其中单个区间为 intervals[i] = [starti, endi]. 请你合并所有重叠的区间, 并返回一个不重叠的区间数组, 该数组需恰好覆盖输入中的所有区间.

> 有点是否可触达的感觉, 按左端点排序, 先划定一个区间(第一个区间的范围)  
> 遍历所有区间, 如果有重叠就更新右端点, 没有就将前一个区间加入

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        List<int[]> list = new ArrayList<>();
        int l = intervals[0][0], r = intervals[0][1];
        for (int[] e : intervals) {
            // 新区间
            if (r < e[0]) {
                list.add(new int[]{l, r});
                l = e[0];
                r = e[1];
            }
            // 融合
            else r = Math.max(r, e[1]);
        }
        //最后的区间没加
        list.add(new int[]{l, r});

        int[][] res = new int[list.size()][];
        for (int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }
}
```

## 区间重叠高度

### 253. 会议室 II mid

给你一个会议时间安排的数组 intervals, 每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi], 返回 所需会议室的最小数量.

**解法 贪心**

> 先按左端点整体排序, 确定入堆顺序; 然后优先队列中放入右端点, 相当于合并

```java
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        for (int[] e : intervals) {
            if (!heap.isEmpty() && heap.element() <= e[0]) heap.remove();
            heap.add(e[1]);
        }
        return heap.size();
    }
}
```

### 2406. 将区间分为最少组数 mid

给你一个二维整数数组 $intervals$, 其中 $intervals[i] = [left_i, right_i]$ 表示闭区间 $[left_i, right_i]$.

你需要将 $intervals$ 划分为一个或者多个区间组, 每个区间只属于一个组, 且同一个组中任意两个区间不相交.

请你返回 最少 需要划分成多少个组.

如果两个区间覆盖的范围有重叠(即至少有一个公共数字), 那么我们称这两个区间是相交的. 比方说区间$[1, 5]$ 和$[5, 8]$相交.

**解法 1 贪心**

> 先按左端点整体排序, 确定入堆顺序; 然后优先队列中放入右端点, 相当于合并

```java
class Solution {
    public int minGroups(int[][] intervals) {
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        for (int[] e : intervals) {
            if (!heap.isEmpty() && heap.element() < e[0]) heap.remove();
            heap.add(e[1]);
        }
        return heap.size();
    }
}
```

**解法 2 排队上车**

> start 上车, end 下车, 求车上最多的人  
> 差分数组, [s,e]+=1

```java
class Solution {
    public int minGroups(int[][] intervals) {
        int min = Integer.MAX_VALUE, max = 0;
        for (int[] pair : intervals) {
            min = Math.min(min, pair[0]);
            max = Math.max(max, pair[1]);
        }
        int[] diff = new int[max - min + 2];
        for (int[] pair : intervals) {
            diff[pair[0] - min]++;
            diff[pair[1] - min + 1]--;
        }
        int res = 1, sum = 0;
        for (int val : diff) {
            sum += val;
            res = Math.max(res, sum);
        }
        return res;
    }
}
```

## 不重叠区间

### 435. 无重叠区间 mid

给定一个区间的集合 intervals, 其中 intervals[i] = [starti, endi]. 返回 需要移除区间的最小数量, 使剩余区间互不重叠.

区间 [1,2] 和 [2,3] 的边界相互“接触”, 但没有相互重叠.

**解法 贪心**

> 如果 2 个区间重叠, 只能选 1 个. 先开始的不一定先结束, 所以按右端点自然排序, 尽可能早结束  
> 如果左端点小于上一个右端点, 计数

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, Comparator.comparingInt(o -> o[1]));
        Integer lastEnd = null;
        int cnt = 0;
        for (int[] e : intervals) {
            if (lastEnd == null || lastEnd <= e[0]) lastEnd = e[1];
            else cnt++;
        }
        return cnt;
    }
}
```

### 452. 用最少数量的箭引爆气球 mid

有一些球形气球贴在一堵用 XY 平面表示的墙面上. 墙面上的气球记录在整数数组 points, 其中 $points[i] = [x_start, x_end]$ 表示水平直径在 $x_start$ 和 $x_end$ 之间的气球. 你不知道气球的确切 y 坐标.

一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出. 在坐标 x 处射出一支箭, 若有一个气球的直径的开始和结束坐标为 $x_start$, $x_end$, 且满足 $x_start ≤ x ≤ x_end$, 则该气球会被 引爆. 可以射出的弓箭的数量 没有限制. 弓箭一旦被射出之后, 可以无限地前进.

给你一个数组 points, 返回引爆所有气球所必须射出的 最小 弓箭数.

**解法**

> 考虑 3 种(相交 不相交 包含)场景, 按右端点排序, 从右端点射入

```Java
class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points, Comparator.comparingInt(o -> o[1]));
        int cnt = 0;
        Integer lastEnd = null;
        for (int[] e : points) {
            if (lastEnd == null || lastEnd < e[0]) {
                cnt++;
                lastEnd = e[1];
            }
        }
        return cnt;
    }
}
```
