# 区间

## 合并区间

### 56. 合并区间 mid

以数组 intervals 表示若干个区间的集合, 其中单个区间为 intervals[i] = [starti, endi]。请你合并所有重叠的区间, 并返回一个不重叠的区间数组, 该数组需恰好覆盖输入中的所有区间。

> 有点是否可触达的感觉, 按左端点排序, 先划定一个区间(第一个区间的范围)  
> 遍历所有区间, 如果有重叠就更新右端点, 没有就将前一个区间加入

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        List<int[]> list = new ArrayList<>();
        int l = intervals[0][0], r = intervals[0][1];
        for (int[] e : intervals) {
            // 新区间
            if (r < e[0]) {
                list.add(new int[]{l, r});
                l = e[0];
                r = e[1];
            }
            // 融合
            else r = Math.max(r, e[1]);
        }
        //最后的区间没加
        list.add(new int[]{l, r});

        int[][] res = new int[list.size()][];
        for (int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }
}
```

## 区间重叠高度

### 253. 会议室 II mid

给你一个会议时间安排的数组 intervals, 每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi], 返回 所需会议室的最小数量。

**解法 贪心**

> 先按左端点整体排序, 确定入堆顺序; 然后优先队列中放入右端点, 相当于合并

```java
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        for (int[] e : intervals) {
            if (!heap.isEmpty() && heap.element() <= e[0]) heap.remove();
            heap.add(e[1]);
        }
        return heap.size();
    }
}
```

### 2406. 将区间分为最少组数 mid

给你一个二维整数数组 $intervals$, 其中 $intervals[i] = [left_i, right_i]$ 表示闭区间 $[left_i, right_i]$。

你需要将 $intervals$ 划分为一个或者多个区间组, 每个区间只属于一个组, 且同一个组中任意两个区间不相交。

请你返回 最少 需要划分成多少个组。

如果两个区间覆盖的范围有重叠(即至少有一个公共数字), 那么我们称这两个区间是相交的。比方说区间$[1, 5]$ 和$[5, 8]$相交。

**解法 1 贪心**

> 先按左端点整体排序, 确定入堆顺序; 然后优先队列中放入右端点, 相当于合并

```java
class Solution {
    public int minGroups(int[][] intervals) {
        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        for (int[] e : intervals) {
            if (!heap.isEmpty() && heap.element() < e[0]) heap.remove();
            heap.add(e[1]);
        }
        return heap.size();
    }
}
```

**解法 2 排队上车**

> start 上车, end 下车, 求车上最多的人  
> 差分数组, [s,e]+=1

```java
class Solution {
    public int minGroups(int[][] intervals) {
        int min = Integer.MAX_VALUE, max = 0;
        for (int[] pair : intervals) {
            min = Math.min(min, pair[0]);
            max = Math.max(max, pair[1]);
        }
        int[] diff = new int[max - min + 2];
        for (int[] pair : intervals) {
            diff[pair[0] - min]++;
            diff[pair[1] - min + 1]--;
        }
        int res = 1, sum = 0;
        for (int val : diff) {
            sum += val;
            res = Math.max(res, sum);
        }
        return res;
    }
}
```
