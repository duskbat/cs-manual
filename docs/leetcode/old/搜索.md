# 搜索

Breadth First Search

## 最短路径

### 752. 打开转盘锁 mid

> 剑指 Offer II 109. 开密码锁

你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。

锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。

列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。

字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。

> 单词接龙 BFS
> 还能用 A* 算法

```java
class Solution {
    public int openLock(String[] deadends, String target) {
        if ("0000".equals(target)) return 0;
        Set<String> deadSet = new HashSet<>();
        Collections.addAll(deadSet, deadends);
        if (deadSet.contains("0000")) return -1;
        Set<String> visit = new HashSet<>();
        Queue<String> que = new ArrayDeque<>();
        que.add("0000");
        visit.add("0000");
        int res = 0;
        while (!que.isEmpty()) {
            int size = que.size();
            while (size-- > 0) {
                String s = que.remove();
                if (s.equals(target)) return res;
                add(que, visit, s, deadSet);
            }
            res++;
        }
        return -1;
    }

    private void add(Queue<String> que, Set<String> visit, String s, Set<String> deadSet) {
        StringBuilder sb = new StringBuilder(s);
        for (int i = 0; i < 4; i++) {
            char c = s.charAt(i);
            // 上
            sb.setCharAt(i, (char) (c == '9' ? '0' : c + 1));
            String t = sb.toString();
            if (!deadSet.contains(t) && !visit.contains(t)) {
                que.add(t);
                visit.add(t);
            }
            // 下
            sb.setCharAt(i, (char) (c == '0' ? '9' : c - 1));
            t = sb.toString();
            if (!deadSet.contains(t) && !visit.contains(t)) {
                que.add(t);
                visit.add(t);
            }
            // 复位
            sb.setCharAt(i, c);
        }
    }
}
```

## 矩阵最短路径


### 1091. 二进制矩阵中的最短路径 mid

给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。
二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：

路径途经的所有单元格都的值都是 0 。
路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。

```Java
class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
        if (grid[0][0] == 1) return -1;
        int deep = grid.length - 1;
        int length = grid[0].length - 1;
        int[][] dir = {{1, -1}, {1, 0}, {1, 1}, {0, -1}, {0, 1}, {-1, -1}, {-1, 0}, {-1, 1}};

        int cnt = 0;
        Queue<int[]> que = new LinkedList<>();
        que.add(new int[]{0, 0});
        grid[0][0] = 1;

        while (!que.isEmpty()) {
            cnt++;
            int size = que.size();
            while (size-- > 0) {
                int[] o = que.remove();
                if (o[0] == deep && o[1] == length) return cnt;

                for (int[] d : dir) {
                    int x = d[0];
                    int y = d[1];
                    // 出界 | 不能走
                    if (o[0] + x < 0
                            || o[1] + y < 0
                            || o[0] + x > deep
                            || o[1] + y > length
                            || grid[o[0] + x][o[1] + y] == 1) continue;

                    que.add(new int[]{o[0] + x, o[1] + y});
                    grid[o[0] + x][o[1] + y] = 1;
                }
            }
        }
        return -1;
    }
}
```

## 所有路径

### 797. 所有可能的路径 mid

> 剑指 Offer II 110. 所有路径

给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）
graph[i]是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。

```java
class Solution {
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        List<List<Integer>> res = new ArrayList<>();
        dfs(graph, res, new ArrayList<>(), 0);
        return res;
    }

    private void dfs(int[][] graph, List<List<Integer>> res, List<Integer> list,
                     int i) {
        list.add(i);
        if (i == graph.length - 1) {
            res.add(new ArrayList<>(list));
            list.remove(list.size() - 1);
            return;
        }
        for (int e : graph[i]) {
            dfs(graph, res, list, e);
        }
        list.remove(list.size() - 1);
    }
}
```

## 图之间的连通性判定

### 面试题13. 机器人的运动范围 mid

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
> 证明只在两个方向搜索有效

```java
class Solution {
    public int movingCount(int m, int n, int k) {
        int cnt = 0;
        boolean[][] dp = new boolean[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j == 0) {
                    dp[i][j] = true;
                    cnt++;
                    continue;
                }
                int sum = 0;
                int a = i, b = j;
                while (a != 0) {
                    sum += a % 10;
                    a /= 10;
                }
                while (b != 0) {
                    sum += b % 10;
                    b /= 10;
                }
                if (sum <= k
                        && (i - 1 >= 0 && dp[i - 1][j] || j - 1 >= 0 && dp[i][j - 1])
                ) {
                    dp[i][j] = true;
                    cnt++;
                }
            }
        }
        return cnt;
    }
}
``` 



## 矩阵中最外层的连通性


### 994. 腐烂的橘子 mid

在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：

- 值 0 代表空单元格；
- 值 1 代表新鲜橘子；
- 值 2 代表腐烂的橘子。

每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。

返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。

> 0. 取出才算作扩散
> 1. 搜索 2 作为 -1位置(root 取出,扩散数正好==0), 统计新鲜的数量
> 2. 如果新鲜数量==0 return 0
> 3. BFS 扩散, 从队列中取出算扩散到, 将新鲜位置加入que, 同时新鲜数量--, 标记已访问
> 4. 如果新鲜数量>0 return -1

```java
class Solution {
    public int orangesRotting(int[][] grid) {
        // 2 -> 1
        int[][] dic = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        int r = grid.length, c = grid[0].length;
        Queue<int[]> que = new LinkedList<>();
        boolean[][] visit = new boolean[r][c];
        int fresh = 0;
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                if (grid[i][j] == 2) {
                    que.add(new int[]{i, j});
                    visit[i][j] = true;
                } else if (grid[i][j] == 1) fresh++;
            }
        }
        if (fresh == 0) return 0;
        // 从队列中取出算扩散
        int day = -1;
        while (!que.isEmpty()) {
            int size = que.size();
            while (size-- > 0) {
                int[] loc = que.remove();
                int i = loc[0], j = loc[1];
                if (grid[i][j] == 1) fresh--;
                for (int[] d : dic) {
                    int x = i + d[0], y = j + d[1];
                    if (x >= 0 && y >= 0 && x < r && y < c && !visit[x][y]) {
                        visit[x][y] = true;
                        if (grid[x][y] == 1) que.add(new int[]{x, y});
                    }
                }
            }
            day++;
        }
        if (fresh > 0) return -1;
        return day;
    }
}
```

-----------------------------------

## 数组可达性搜索



### 733. 图像渲染 easy

有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j]表示该图画的像素值大小。

你也被给予三个整数 sr , sc 和 newColor 。你应该从像素 image[sr][sc]开始对图像进行 上色填充 。

为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。

最后返回 经过上色渲染后的图像。
> BFS

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        // BFS
        int[][] dic = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        int r = image.length, c = image[0].length;
        boolean[][] visit = new boolean[r][c];
        Queue<int[]> que = new ArrayDeque<>();
        que.add(new int[]{sr, sc});
        while (!que.isEmpty()) {
            int[] arr = que.remove();
            int x = arr[0], y = arr[1];
            visit[x][y] = true;
            for (int[] d : dic) {
                if (x + d[0] < 0 || x + d[0] >= r) continue;
                if (y + d[1] < 0 || y + d[1] >= c) continue;
                if (!visit[x + d[0]][y + d[1]] && image[x][y] == image[x + d[0]][y + d[1]])
                    que.add(new int[]{x + d[0], y + d[1]});
            }
            image[x][y] = color;
        }
        return image;
    }
}
```