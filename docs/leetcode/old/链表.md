# 链表

## 归并链表


## 找值

### 876. 链表的中间结点 easy

给定一个头结点为 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode p1 = head, p2 = head;
        boolean flag = true;
        while (p1 != null) {
            flag ^= true;
            if (flag) p2 = p2.next;
            p1 = p1.next;
        }
        return p2;
    }
}
```

## 删除节点

### 剑指 Offer 18. 删除链表的节点 easy

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

```java
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode zero = new ListNode(0);
        zero.next = head;
        ListNode node = zero;
        while(node!=null&&node.next!=null){
            if(node.next.val==val){
                node.next = node.next.next;
            }   
            node = node.next;
        }
        return zero.next;
    }
}
```

## 拆分


## 重排


## 循环链表插入

### 剑指 Offer II 029. 排序的循环链表 mid

给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。

给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。

如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。

如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。

> 注意一下全是相同元素的情况

```java
class Solution {
    public Node insert(Node head, int insertVal) {
        if (head == null) {
            head = new Node(insertVal);
            head.next = head;
            return head;
        }
        Node node = head.next;
        boolean flag = false;
        while (node != head) {
            if (node.val <= node.next.val) {
                if (insertVal >= node.val && insertVal <= node.next.val) {
                    insert(node, node.next, insertVal);
                    flag = true;
                    break;
                }
            } else {
                if (insertVal >= node.val || insertVal <= node.next.val) {
                    insert(node, node.next, insertVal);
                    flag = true;
                    break;
                }
            }
            node = node.next;
        }
        // 全是重复元素的情况
        if (!flag) insert(head, head.next, insertVal);
        return head;
    }

    private void insert(Node pre, Node next, int val) {
        pre.next = new Node(val);
        pre.next.next = next;
    }
}

```

## 打印

### 剑指 Offer 06. 从尾到头打印链表 easy

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

```java
class Solution {
    public int[] reversePrint(ListNode head) {
        int len = 0;
        ListNode node = head;
        while (node != null) {
            len++;
            node = node.next;
        }
        int[] res = new int[len];
        node = head;
        for (int i = len - 1; i >= 0; i--) {
            res[i] = node.val;
            node = node.next;
        }
        return res;
    }
}
```

## 复杂链表

