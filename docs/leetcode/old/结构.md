## 最大队列

### 面试题 59 - II. 队列的最大值 mid

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数 max_value、push_back 和 pop_front 的均摊时间复杂度都是 O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

> 单调减队列, 头部最大

```java
class MaxQueue {
    Queue<Integer> que = new LinkedList<>();
    Deque<Integer> max = new LinkedList<>();


    public int max_value() {
        if (max.isEmpty()) return -1;
        return max.getFirst();
    }

    public void push_back(int value) {
        while (!max.isEmpty() && max.getLast() < value) {
            max.removeLast();
        }
        max.addLast(value);
        que.add(value);
    }

    public int pop_front() {
        if (que.isEmpty()) return -1;
        int res = que.remove();
        // 关键在这, 如何确定单调队列中的最大元素还在队列中
        if (res == max.getFirst()) max.removeFirst();
        return res;
    }
}
```

## Trie (前缀树)


### 820. 单词的压缩编码 mid

单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：

-   words.length == indices.length
-   助记字符串 s 以 '#' 字符结尾
-   对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 '#' 字符结束（但不包括 '#'）的 子字符串 恰好与 words[i] 相等

给你一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。

> 分叉的不能共享前缀 aTime bTime
>
> -   word 需要倒序建树;
> -   如果不先排序的话, 很难在建树的过程中统计, 主要问题是分叉的不能共享前缀;
> -   我们可以先建树再统计, 可以建树之后 DFS; 也可以存储所有叶子节点, 然后遍历统计;

```java
class Solution {
    static class Node {
        Node[] table = new Node[26];
        boolean isLeaf;
    }

    // 分叉的不能共享前缀
    public int minimumLengthEncoding(String[] words) {
        Node root = new Node();
        Map<Node, Integer> map = new HashMap<>();
        for (String s : words) {
            int cnt = 1;
            Node p = root;
            for (int i = s.length() - 1; i >= 0; i--) {
                cnt++;
                int idx = s.charAt(i) - 'a';
                if (p.table[idx] == null) {
                    p.table[idx] = new Node();
                    if (i == 0) map.put(p.table[idx], cnt);
                } else if (i != 0 && p.table[idx].isLeaf) {
                    p.table[idx].isLeaf = false;
                    map.remove(p.table[idx]);
                }
                p = p.table[idx];
            }
            p.isLeaf = true;
        }
        int res = 0;
        for (var entry : map.entrySet()) {
            res += entry.getValue();
        }
        return res;
    }
}
```


## LRU

### 933. 最近的请求次数 easy

写一个 RecentCounter 类来计算特定时间范围内最近的请求。

请你实现 RecentCounter 类：

-   RecentCounter() 初始化计数器，请求数为 0 。
-   int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。

保证 每次对 ping 的调用都使用比之前更大的 t 值。

```java
class RecentCounter {

    Queue<Integer> que = new ArrayDeque<>();

    public int ping(int t) {
        que.add(t);
        while (!que.isEmpty() && que.element() < t - 3000) {
            que.remove();
        }
        return que.size();
    }
}
```
