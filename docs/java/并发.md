# 并发

闲言少叙, 并发的目的在于充分利用计算资源(CPU), 其难点在于如何处理共享资源

## JVM 线程模型

JVM 是运行在 OS 上的, JVM 的线程与操作系统的线程之间存在某种映射关系, 这种规范和协议就是 JVM 线程模型

### Linux 内核的线程概念

Linux 线程是个抽象概念, 是通过轻量级进程实现的  
进程与轻量级进程的差异: 1 个进程拥有自己独立的地址空间, 而轻量级进程没有, 只能共享同 1 个轻量级进程组下的地址空间

### 主流的线程模型

-   1 用户线程对 1 操作系统线程  
    优点: 线程之间独立  
    缺点: 用户线程调度会直接影响内核线程, 降低性能

    > JVM 属于此类

-   多用户线程对 1 操作系统线程  
    优点: 线程调度可以在用户空间完成, 减少状态切换  
    缺点: 1 个用户线程阻塞, 影响其他线程

    > JVM 早期采用

-   多用户线程对多操作系统线程  
    优点: 综合上述 2 者优点  
    缺点: 实现复杂

    > Golang 的 GMP 线程模型

## 共享资源访问之:悲观锁

java 的设计是将锁放在对象头中, 也就是将对象视为共享资源

### 对象头中的锁标志

Mark Word: 32bit

```mermaid
block-beta
  columns 13
  r0<["锁状态"]>(right):1    r0a["23bit"]:4 r0b["2bit"]:2 r0c["4bit"]:3 r0d["1bit"]:1 r0e["2bit"]:2
```

```mermaid
block-beta
  columns 13
  r1<["无锁"]>(right):1      hashcode:6 r1a["分代年龄"]:3 r1b["偏向锁 0"]:1 r1c["锁标志位 01"]:2
```

```mermaid
block-beta
  columns 13
  r2<["偏向锁"]>(right):1    线程id:4 Epoch:2 r2a["分代年龄"]:3 r2b["偏向锁1"]:1 r2c["锁标志位 01"]:2
```

```mermaid
block-beta
  columns 13
  r3<["轻量级锁"]>(right):1  指向栈中锁记录的指针:10 r3a["锁标志位 00"]:2
```

```mermaid
block-beta
  columns 13
  r4<["重量级锁"]>(right):1  指向重量级锁的指针:10 r4a["锁标志位 10"]:2
```

### 锁升级

---

原始比例:

```mermaid
block-beta
  columns 33
  r0<["锁状态"]>(right):1   r0a["23bit"]:23 r0b["2bit"]:2 r0c["4bit"]:4 r0d["1bit"]:1 r0e["2bit"]:2
  r1<["无锁"]>(right):1      hashcode:25 r1a["分代年龄"]:4 r1b["偏向锁 0"]:1 r1c["锁标志位 01"]:2
  r2<["偏向锁"]>(right):1    线程id:23 Epoch:2 r2a["分代年龄"]:4 r2b["偏向锁1"]:1 r2c["锁标志位 01"]:2
  r3<["轻量级锁"]>(right):1  指向栈中锁记录的指针:30 r3a["锁标志位 00"]:2
  r4<["重量级锁"]>(right):1  指向重量级锁的指针:30 r4a["锁标志位 10"]:2
```
