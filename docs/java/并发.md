# 并发

闲言少叙, 并发的目的在于充分利用计算资源(CPU), 其难点在于如何处理共享资源

## JVM 线程模型

JVM 是运行在 OS 上的, JVM 的线程与操作系统的线程之间存在某种映射关系, 这种规范和协议就是 JVM 线程模型

### Linux 内核的线程概念

Linux 线程是个抽象概念, 是通过轻量级进程实现的  
进程与轻量级进程的差异: 1 个进程拥有自己独立的地址空间, 而轻量级进程没有, 只能共享同 1 个轻量级进程组下的地址空间

### 主流的线程模型

-   1 用户线程对 1 操作系统线程  
    优点: 线程之间独立  
    缺点: 用户线程调度会直接影响内核线程, 降低性能

    > JVM 属于此类

-   多用户线程对 1 操作系统线程  
    优点: 线程调度可以在用户空间完成, 减少状态切换  
    缺点: 1 个用户线程阻塞, 影响其他线程

    > JVM 早期采用

-   多用户线程对多操作系统线程  
    优点: 综合上述 2 者优点  
    缺点: 实现复杂

    > Golang 的 GMP 线程模型

## 共享资源访问之:悲观锁

java 的设计是将锁放在对象头中, 也就是将对象视为共享资源

### 对象头中的锁标志

Mark Word: 32bit

```mermaid
block-beta
  columns 13
  r0<["锁状态"]>(right):1 r0a["23bit"]:4 r0b["2bit"]:2 r0c["4bit"]:3 r0d["1bit"]:1 r0e["2bit"]:2
```

```mermaid
block-beta
  columns 13
  r1<["无锁"]>(right):1 r1a["hashcode"]:6 r1b["分代年龄"]:3 r1c["偏向锁 0"]:1 r1d["锁标志位 01"]:2
```

```mermaid
block-beta
  columns 13
  r2<["偏向锁"]>(right):1 r2a["线程id"]:4 r2b["Epoch"]:2 r2c["分代年龄"]:3 r2d["偏向锁 1"]:1 r2e["锁标志位 01"]:2
```

```mermaid
block-beta
  columns 13
  r3<["轻量级锁"]>(right):1 r3a["指向栈中锁记录的指针"]:10 r3b["锁标志位 00"]:2
```

```mermaid
block-beta
  columns 13
  r4<["重量级锁"]>(right):1 r4a["指向重量级锁的指针"]:10 r4b["锁标志位 10"]:2
```

### 锁升级

---

原始比例:

```mermaid
block-beta
  columns 33
  r0<["锁状态"]>(right):1 r0a["23bit"]:23 r0b["2bit"]:2 r0c["4bit"]:4 r0d["1bit"]:1 r0e["2bit"]:2
  r1<["无锁"]>(right):1 r1a["hashcode"]:25 r1b["分代年龄"]:4 r1c["偏向锁 0"]:1 r1d["锁标志位 01"]:2
  r2<["偏向锁"]>(right):1 r2a["线程id"]:23 r2b["Epoch"]:2 r2c["分代年龄"]:4 r2d["偏向锁 1"]:1 r2e["锁标志位 01"]:2
  r3<["轻量级锁"]>(right):1 r3a["指向栈中锁记录的指针"]:30 r3b["锁标志位 00"]:2
  r4<["重量级锁"]>(right):1 r4a["指向重量级锁的指针"]:30 r4b["锁标志位 10"]:2

  classDef front height:100px;
  class r0,r0a,r0b,r0c,r0d,r0e, r1,r1a,r1b,r1c,r1d, r2,r2a,r2b,r2c,r2d,r2e, r3,r3a,r3b, r4,r4a,r4b front

```
